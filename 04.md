2020.10.31
---------------------------------------------------------------

将opencv的矩阵以二进制的形式保存：

```c++
#include <opencv2/opencv.hpp>
#include <iostream>
using namespace cv;
using namespace std;
int main(int argc, char const *argv[]) {
    Mat img=imread("1.jpg");
    ///写入数据
    ofstream outFile("data.bin", ios::out | ios::binary);
    outFile.write(reinterpret_cast<char*>(img.data), sizeof(uchar)*img.rows*img.cols*img.channels());///必须写出数据有多长
    ///读出数据
    ifstream inFile("data.bin", ios::in | ios::binary);
    uchar p;
    vector<uchar> InData
    for (int i = 0; i < img.rows*img.cols*img.channels(); ++i) {///循环次数=图片像素数据大小
        inFile.read(reinterpret_cast<char*>(&p),sizeof(p));///每次只读一个像素点数据
        InData.push_back(p);
    }
    Mat out1(InData);///现在的矩阵只是一维的
    Mat out2=out1.reshape(3,img.rows).clone();///将一维矩阵转化为三维
//测试显示结果
    imshow("",out2);
    waitKey();
}
```

将opencv的矩阵以[xml]( https://docs.opencv.org/4.2.0/dd/d74/tutorial_file_input_output_with_xml_yml.html )的形式保存。



2020.12.19
---------------------------------------------------------------

- 在windows上用ffmpeg开启网络摄像头，并读取yuv文件。

1. 列出摄像头的详情

```bash
ffmpeg -y -f vfwcap -i list
```

结果输出

```bash
ffmpeg version 4.3.1 Copyright (c) 2000-2020 the FFmpeg developers
  built with gcc 10.2.0 (Rev1, Built by MSYS2 project)
  configuration: --prefix=/mingw64 --target-os=mingw32 --arch=x86_64 --disable-debug --disable-static --enable-dxva2 --enable-d3d11va --enable-fontconfig --enable-gnutls --enable-gpl --enable-libaom --enable-libass --enable-libbluray --enable-libcaca --enable-libcelt --enable-libdav1d --enable-libfreetype --enable-libgsm --enable-libmfx --enable-libmodplug --enable-libmp3lame --enable-libopencore_amrnb --enable-libopencore_amrwb --enable-libopenjpeg --enable-libopus --enable-librtmp --enable-libspeex --enable-libsrt --enable-libtheora --enable-libvorbis --enable-libx264 --enable-libx265 --enable-libxvid --enable-libvpx --enable-libwebp --enable-libxml2 --enable-openal --enable-libwavpack --enable-pic --enable-postproc --enable-runtime-cpudetect --enable-shared --enable-static --enable-swresample --enable-version3 --enable-vulkan --enable-zlib --disable-doc
  libavutil      56. 51.100 / 56. 51.100
  libavcodec     58. 91.100 / 58. 91.100
  libavformat    58. 45.100 / 58. 45.100
  libavdevice    58. 10.100 / 58. 10.100
  libavfilter     7. 85.100 /  7. 85.100
  libswscale      5.  7.100 /  5.  7.100
  libswresample   3.  7.100 /  3.  7.100
  libpostproc    55.  7.100 / 55.  7.100
[vfwcap @ 00000171b5328340] Driver 0
[vfwcap @ 00000171b5328340]  Microsoft WDM Image Capture (Win32)
[vfwcap @ 00000171b5328340]  Version:  10.0.17763.1
list: I/O error
```

在**12**行`[vfwcap @ 00000171b5328340] Driver 0`说明电脑有摄像头0。

2.  采用usb摄像头录取视频命令

```bash
ffmpeg -t 1 -y -f vfwcap -r 25 -i 0 out.yuv
```

   `-t` 录制总时间 1s

   `-y` 覆盖原有的输出文件（如果存在的话）

   `-f` 网络摄像头的采集设备为 vfwcap，读取的数据是原始的

   `-r` 录取视频的帧率

   `-i` 开启摄像头设备的编号

如果电脑又多个摄像头，在这一步会让你选择。

- 或者

```bash
ffmpeg -y -t 1 -f vfwcap -r 25 -i 0 -frame_size 640x480 -f rawvideo out.rgb
```

3. 如何播放原始的yuv视频文件

```bash
ffplay -f rawvideo -video_size 640x480 -pixel_format yuvj422p out.yuv
```


4. 如何分割每一帧的原始raw图片

```bash
ffmpeg -s 640x480 -pixel_format yuvj422p -i out.yuv images%03d.raw
```

2020.12.26
---------------------------------------------------------------

- C语言调用C++的库

例如，原c++文件circle.h与circle.cpp代码如下：

```c++
#ifndef A823ASD
#define A823ASD

class Circle{
public:
    Circle(float radius);
    float getArea() const;

private:
    float _radius;

};

#endif
```

<br/>

```c++
#include "circle.h"
Circle::Circle(float radius):_radius(radius){}

float Circle::getArea() const {
    return 3.14159*this->_radius*this->_radius;
}
```

需要定义wrapper文件（circle_c.h和circle_c.cpp）

```c++
#ifndef A823432qASD
#define A823432qASD

#ifdef __cplusplus
    extern "C"{
#endif
        
                extern void* Circle_C_init(float radius);
                extern void Circle_C_free(void* circle);
                extern float Circle_C_getArea(void* circle);

#ifdef __cplusplus
    }
#endif

#endif
```

<br/>

```c++
#include "circle_c.h"
#include "circle.h"
extern void* Circle_C_init(float radius){
    return new Circle(radius);
}
extern void Circle_C_free(void* circle){
    Circle *c = (Circle*) circle;
    delete c;
}
extern float Circle_C_getArea(void* circle){
    Circle *c = (Circle*) circle;
    return c->getArea();
}
```

创建Makefile文件，编写生成静态库的文件：

```makefile
# 用gcc调用c++生成的静态库语法
all: libcircle_c.a
	gcc main.c circle_c.h -L. -lcircle_c -lstdc++ -o mixed

# 用g++生成可用于其他c++工程调用的静态库libcircle.a
libcircle.a: circle.o
	ar -r libcircle.a circle.o
circle.o: circle.cpp circle.h
	g++ -c circle.h circle.cpp

# 用g++生成可用于c工程调用的静态库libcircle_c.a
libcircle_c.a: circle.o circle_c.o
	ar -r libcircle_c.a circle_c.o circle.o
circle_c.o: circle.cpp circle.h
	g++ -c circle_c.h circle_c.cpp

# 用于清理生成的文件
.PHONY: clean
clean:
	rm -rf *.o *.a *.gch
```

用C语言调用时只需要有circle_c.h和libcircle_c.a即可。

<br/>

- C++语言调用C的库

例如，原c文件circle_C.h(**需要额外添加extern ”C”和__cplusplus宏判断**)与circle_C.c代码如下：

```C
#ifndef A823ASD
#define A823ASD

#ifdef __cplusplus
    extern "C"{
#endif

        float getArea(float radius);

#ifdef __cplusplus
    }
#endif

#endif
```

<br/>

```c
#include "circle_C.h"
float getArea(float radius){
    return 3.14159 * radius * radius;
}
```

创建Makefile文件，生成基于C语言函数的静态库：

```makefile
all: libcircle_c.a
	g++ main.cpp -L. -lcircle_c -std=c++11  -o mixed

libcircle_c.a: circle_c.o
	ar -r libcircle_c.a circle_c.o
circle_c.o: circle_c.h circle_c.c
	gcc -c circle_c.h circle_c.c

.PHONY: clean
clean:
	rm -rf *.o *.a *.gch
```

用C++或者C语言调用时只需要有circle_c.h和libcircle_c.a即可，circle_c.h和libcircle_c.a可以同时兼容C语言和C++语言。



2021.1.3
---------------------------------------------------------------

